<!DOCTYPE html>
<html>
<head>
    <title>Spectrum Customizer</title>
    <style>
         body {
           font-family: Arial, Helvetica, sans-serif;
           background-color: #eee;
         }
        </style>
    <meta name="viewport" content="width=device-width, initial-scale=1" >
</head>
<body>
<div id="spectrum-customizer"></div>
<script>
          window.customizerWrapperId = 'spectrum-customizer';
</script>

<script>
         window.customizerWrapperId = 'spectrum-customizer';

         window.pendingPriceUpdates = {};
         window.pendingImageUpdate;
         window.hasPendingImage = false;

         window.spectrumAddToCart = function(skus, recipeSetId, options) {

           let safeOptions = typeof options === 'undefined' ? {} : options;

           if (typeof options === 'undefined') {
             safeOptions = {};
           } else if (Array.isArray(options)) {
             safeOptions = consolidateOptions(options);
           } else {
             safeOptions = escapeOptions(options);
           }

           let skuData = Array.isArray(skus) ? skus : [skus];

           let cartData = {
             skus: skuData.map(sku => typeof sku === 'undefined' ? '' : sku),
             recipeSetId: recipeSetId,
             options: safeOptions
           };

           if (typeof window.SpectrumNative !== 'undefined') {
             window.SpectrumNative.addToCart(JSON.stringify(cartData));
           } else if (window.webkit && typeof window.webkit.messageHandlers.addToCart !== 'undefined') {
             window.webkit.messageHandlers.addToCart.postMessage(cartData);
           }
         }

         window.spectrumGetPriceAndInventory = function (skus, options) {

           return new Promise((resolve, reject) => {

             const callbackId = generateId();

             window.pendingPriceUpdates[callbackId] = {
               resolve: resolve,
               reject: reject
             };
             let skuData = Array.isArray(skus) ? skus : [skus];
             skuData = skuData.map(sku =>  {
               let result = typeof sku === 'undefined' ? '' : sku;
               if (result === '' && window.spectrumLoadProduct !== '' && window.spectrumLoadProduct !== null) {
                 result = window.spectrumLoadProduct;
               }
               return result;

             });

             const priceData = {
               callbackId: callbackId,
               skus: skuData,
               options: typeof options === 'undefined' ? {} : escapeOptions(options)
             };

             if (typeof window.SpectrumNative !== 'undefined') {
               window.SpectrumNative.getPrice(JSON.stringify(priceData));
             } else if (window.webkit && typeof window.webkit.messageHandlers.addToCart !== 'undefined') {
               window.webkit.messageHandlers.getPrice.postMessage(priceData);
             } else {
               reject();
             }
           });
         }

         window.spectrumGetPendingImage = function spectrumGetPendingImage() {

           if (hasPendingImage && window.pendingImage !== null) {
             return window.pendingImage;
           } else {
             window.pendingImage = new Promise((resolve, reject) => {
                if (window.webkit && typeof window.webkit.messageHandlers.getPendingImage !== 'undefined') {
                  window.pendingImageUpdate = {
                    resolve: resolve,
                    reject: reject
                  };
                  window.webkit.messageHandlers.getPendingImage.postMessage('');
                } else {
                  reject();
                }
             });
             return window.pendingImage
             .then(data => {
               if (!data) {
                 return;
               }
               let localState = localStorage.getItem(data.storageKey);
               if (localState) {
                 let savedState = JSON.parse(localState);
                 let state = savedState.find(s => s.productHandle === data.productHandle);
                 let feature = state.features.find(f => f.featureHandle === data.featureHandle);
                 if (feature && data.response.length > 0) {
                   let uploadUri = data.response.length > 1 ? data.response[1].uri : data.response[0].uri;
                   feature.valueString = uploadUri;

                   let image = state.images.find(i => i.url === uploadUri);
                   if (typeof image === 'undefined') {
                     state.images.push({
                       url: uploadUri,
                       height: data.height,
                       width: data.width,
                       rotation: 0,
                       scale: 1,
                       userScale: 1
                     });
                   }
                 }
                 localStorage.setItem(data.storageKey, JSON.stringify(savedState));
               }
               return data;
             });
           }
         }

         window.spectrumCancelImageUpload = function () {
           window.hasPendingImage = false;
           if (window.pendingImageUpdate) {
             window.pendingImageUpdate.reject();
           }
         };

         window.spectrumClearPendingImage = function() {
           window.hasPendingImage = false;
         };

         function spectrumGetImage(options) {
           return new Promise((resolve, reject) => {
              if (window.webkit && typeof window.webkit.messageHandlers.getImage !== 'undefined') {
                window.pendingImageUpdate = {
                  resolve: resolve,
                  reject: reject
                };
                window.webkit.messageHandlers.getImage.postMessage(options);
              } else {
                reject();
              }
           });
         }

        function resolveArtwork(src) {
          window.hasPendingImage = arguments.length !== 0;
          if (window.pendingImageUpdate) {
            window.pendingImageUpdate.resolve(src);
          }
        }

        function consolidateOptions(optionList) {
          return optionList.reduce((result, opt) => {
            let safeOption = escapeOptions(opt);
            for (let key in safeOption) {
              result[key] = safeOption[key]
            }
            return result;
          }, {});
        }

          function escapeOptions(options) {
            let result = {};
            for (let key in options) {
              if (options.hasOwnProperty(key)) {
                let opt = options[key];
                if (key === 'thumbnailUrls') {
                  extractAngles(opt, result);
                } else {
                  result[key] = typeof opt !== "string" ? JSON.stringify(opt) : opt;
                }
              }
            }
            return result;
          }

          function extractAngles(viewAngles, result) {
            for (let key in viewAngles) {
              result[key] = viewAngles[key];
            }
          }

         function resolvePrice(callbackId, prices) {
           if (window.pendingPriceUpdates.hasOwnProperty(callbackId)) {
             window.pendingPriceUpdates[callbackId].resolve(prices);
           }
         }

         function generateId() {
           return parseInt(Math.random() * 10000000);
         }

         window.loadCustomizer = function (script) {
           let elem = document.createElement('script');
           elem.src = script;
           elem.onload = function() {
             if (window.spectrumInit) {
               window.spectrumInit();
             }
           };
           document.getElementsByTagName('body')[0].append(elem);
         }

         window.spectrumThrowError = function (err) {
           console.error(err);
         };

        </script>
</body>
</html>
